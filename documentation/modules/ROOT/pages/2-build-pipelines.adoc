= 2. CI/CD 파이프라인 구축 - 30분
:imagesdir: ../assets/images

== 이 랩의 목표

이 랩의 목표는 link:https://access.redhat.com/documentation/en-us/openshift_container_platform/4.11/html-single/cicd/index#op-detailed-concepts[OpenShift 파이프라인^]을 사용하여 현대화된 customer 애플리케이션을 OpenShift에 빌드하고 배포하는 것입니다. 다음 단계로 이를 달성할 수 있습니다:

* https://tekton.dev/[Tekton^] 파이프라인을 사용하여 Apache Tomcat 대신 Red Hat JBoss Web Server를 런타임으로 활용하여 새로운 현대화된 애플리케이션을 빌드 및 배포합니다.
* OpenShift에서 실행 중인 새 PostgreSQL 데이터베이스에 연결하도록 *customers* 서비스의 설정을 구성합니다.
* *customers* 서비스를 테스트합니다.

== 2.1. Helm을 사용하여 PostgreSQL DBMS 연결 업데이트하기

=== 2.1.1. 왜 OpenShift와 Helm을 사용하는가?

https://docs.openshift.com/container-platform/4.10/applications/working_with_helm_charts/understanding-helm.html[Helm^]은 Kubernetes에서 컨테이너화된 애플리케이션의 패키징과 배포를 표준화하고 단순화하는 패키지 및 설치 관리자입니다. 이를 통해 개발자는 애플리케이션을 패키지화하여 조직 내외의 누구나 쉽게 공유하고 배포할 수 있게 합니다.

Helm은 애플리케이션 설치 및 기본 구성 관리를 자동화하는 *day-1* 작업뿐만 아니라, 간단한 업그레이드 및 롤백을 수행하는 일부 *day-2* 작업에도 사용할 수 있습니다.

=== 2.1.2. 새로운 JDBC 설정을 위한 Helm 차트 업데이트

현재 OpenShift 클러스터의 *customers* 애플리케이션은 레거시 가상화 인프라에서 실행 중인 PostgreSQL 데이터베이스에 연결하려고 시도하고 있어 연결 실패가 발생합니다. 문제를 해결하려면 OpenShift에 마이그레이션된 PostgreSQL 데이터베이스를 가리키도록 *JDBC* 설정을 업데이트해야 합니다.

현재 JDBC 설정은 현대화된 Globex 소매 시스템의 Day 1 및 2 작업을 자동화하기 위해 _Helm 차트_ 로 관리됩니다. link:https://codeserver-codeserver-%USERID%.%SUBDOMAIN%[VS Code 서버^]로 돌아가서 *helm/customer-tomcat-gitops* 디렉터리를 확인하세요.

JDBC 구성을 정의할 수 있도록 Helm 차트가 어떻게 설정되는지 이해하기 위해 `secret/persistence.properties` 파일을 살펴보세요.

image::gitops-persistence.png[gitops-persistence]

[NOTE]
====
*JDBC 설정* 업데이트에 대한 최선의 개발자 실천 방법은 VS Code 서버에서 로컬로 설정을 변경한 후, Gitea 리포지토리에 변경사항을 커밋하고 푸시하는 것입니다. 그러면 `OpenShift pipeline과 GitOps` 가 자동으로 OpenShift의 `ConfigMap` 및 `Secret` 객체를 업데이트합니다.
link:https://argocd-server-retail-%USERID%.%SUBDOMAIN%[ArgoCD 웹 콘솔^]에 접속하세요. `LOG IN VIA OPENSHIFT` 를 클릭합니다.
====

image::argocd-login.png[argocd-login]

이전에 OpenShift 클러스터에 로그인하지 않은 경우 다음 자격 증명을 사용하여 로그인합니다. OpenShift는 이미 https://access.redhat.com/products/red-hat-single-sign-on/[Red Hat Single Sign On^]과 통합되어 있습니다.

image::sso_login.png[openshift_login]

* 다음 자격증명으로 로그인하세요:

** 사용자 이름: `%USERID%`
** 비밀번호: `{openshift-password}`

* *Allow selected permissions* 을 클릭합니다.

image::argo_authorize.png[openshift_login]

이제 `customers-tomcat-gitops` 의 상태가 *Progressing* 임을 확인할 수 있습니다. 애플리케이션이 아직 이전 데이터베이스의 호스트 이름(예: *postgresql-db-database*)을 참조하고 있기 때문입니다.

image::argocd-application-degrade.png[argocd-application-degrade]

`applications` 를 클릭하세요.

image::argocd-application-click-applications.png[argocd-application-click-applications]

애플리케이션의 상세 페이지를 표시하려면 `APP DETAILS` 를 클릭합니다. 그런 다음 `PARAMETER` 탭으로 전환하고 `EDIT` 을 클릭합니다.

image::argocd-application-details.png[argocd-application-details]

`customerDatabase` 의 키와 값을 Red Hat OpenShift 상의 PostgreSQL 가상머신을 참조하는 아래의 데이터로 교체합니다. 다음과 같아야 합니다:

* customerDatabase.hostname: `postgresql-customer`
* customerDatabase.password: `customer`
* customerDatabase.user: `customer`

image::argocd-application-update.png[argocd-application-update]

[NOTE]
====
하단의 _user_ 필드에 *user1* 이 표시될 수 있습니다. 이 값은 기본값이기 때문에 ArgoCD가 _customers_ 애플리케이션에 렌더링하지 않습니다. *VALUES* 섹션에서 당신의 유저 이름과 함께 실제 값을 확인할 수 있습니다.
====

`SAVE` 를 클릭한 다음 오른쪽 상단의 `X` 를 클릭하여 팝업 창을 닫습니다.

이제 application 객체를 업데이트했으므로 `customers-tomcat-gitops` 애플리케이션의 상태가 `OutOfSync` 로 표시됩니다.

image::argocd-application-outofsync.png[argocd-application-outofsync]

`SYNC` 를 클릭한 다음, 왼쪽 팝업 창에서 `SYNCHRONIZE` 를 클릭합니다.

애플리케이션을 동기화하는 데 몇 초가 걸립니다. 완료되면 다음과 같이 표시됩니다:

image::argocd-application-synced.png[argocd-application-synced]

OpenShift 웹 콘솔로 돌아가서 link:https://console-openshift-console.%SUBDOMAIN%/k8s/ns/retail-%USERID%/secrets/customers-secret[customers-secret^]을 확인하세요.

image::argocd-application-secret-reveral.png[argocd-application-secret-reveral]

`Reveral values` 를 클릭하여 업데이트된 JDBC 설정 값을 확인합니다.

image::argocd-application-secret.png[argocd-application-secret]

== 2.2. OpenShift Pipelines 실행

=== 2.2.1. 왜 OpenShift Pipelines인가?

OpenShift 파이프라인은 https://tekton.dev[Tekton^]에 기반한 *kubernetes 네이티브 CI/CD* 프레임워크를 제공하여 파이프라인을 설계하고 실행하며, CI/CD 파이프라인의 각 단계를 자체 컨테이너에서 실행하여, 이를 통해 파이프라인의 각 단계가 독립적으로 확장하여 파이프라인의 요구 사항을 충족할 수 있습니다.

CI/CD 개념(`pipeline`, `task`, `step` 등)을 Kubernetes/OpenShift의 사용자 정의 리소스 정의(CRD)로 확장함으로써 OpenShift 파이프라인은 Kubernetes의 확장성, 보안성, 배포 용이성을 증가시킵니다.

image::tekton-concept.png[tekton-concept]

파이프라인은 여러 단계로 구성된 _task_ 를 실행합니다. 각 _tasks_ 들은 단일 목적을 가지고 있니다.

* *Clone Repository* 는 타겟 Git Repository에서 소스 코드를 다운로드합니다. 
* *Build from Source* 는 소스 코드에서 애플리케이션 아티팩트를 빌드합니다. 이 task에서는 Git Repository의 하위 디렉토리를 선택할 수 있기 때문에, 단일 Git Repository에서 여러 애플리케이션/구성 요소를 사용할 수 있습니다. *그러나 이런 방식으로 다양한 서비스/구성요소의 버전을 관리하는 것은 권장되지 않습니다.* 최적의 접근 방식은 각 구성요소의 라이프사이클을 독립적으로 관리하기 위해 각 구성요소에 대한 전용 Git Repository를 갖는 것입니다. 이 랩에서는 단순화를 위해 모든 예시용 자료를 하나의 저장소에 모으기로 결정했습니다.
* *Build Image* 는 애플리케이션에 있는 Dockerfile을 사용하여 이미지를 빌드하고 타겟 레지스트리에 이미지를 푸시합니다. 이미지에는 포함된 소스의 short commit hash가 태그로 지정됩니다.  
* *Update Manifest* 는 short commit hash 태그를 사용하여 Git에서 애플리케이션 매니페스트를 업데이트하고 새로 빌드된 이미지를 가리킵니다.그런 다음 애플리케이션의 배포가 ArgoCD에 위임되고, ArgoCD는 변경사항에 대해 구성 저장소(configuration repository)를 지속적으로 폴링(polling)하고 모든 OpenShift 객체를 그에 따라 생성/업데이트합니다. 

파이프라인은 다음 매개변수를 허용합니다. 

* *git-url*: 타겟 Git Repository의 URL입니다. 
* *git-branch*: 작업할 타겟 브랜치입니다.(기본값: _main_ ) 
* *app-subdir*: 애플리케이션 소스 코드가 저장된 Git Repository의 하위 디렉토리입니다. 
* *target-namespace*: 애플리케이션을 배포할 네임스페이스/프로젝트입니다. 
* *target-registry*: 빌드된 이미지를 푸시할 레지스트리입니다. (기본값: _image-registry.openshift-image-registry.svc:5000_, 즉 OpenShift의 내부 컨테이너 레지스트리)

=== 2.2.2 고객 파이프라인 실행 

소스 코드가 커밋되면 자동으로 파이프라인을 실행하도록 웹훅(webhooks)과 이벤트 리스너/트리거(event listeners/triggers)를 구성할 수 있습니다. 

이 실습에서는 단순화를 위해 파이프라인 실행을 수동으로 트리거합니다. 

새 브라우저를 열어 link:https://console-openshift-console.%SUBDOMAIN%/dev-pipelines/ns/cicd-%USERID%[OpenShift Pipeline^]에 액세스합니다.

그러면 _Developer perspective_ 에서 `cicd-%USERID%` 프로젝트에 미리 정의된 `java-deployment` 파이프라인이 표시됩니다. 

파이프라인을 클릭합니다. 

image::ama-pipeline.png[ama-pipeline] 

파이프라인을 실행하려면 *Actions* 드롭다운에서 `Start` 를 클릭합니다. 

image::ama-pipeline-start.png[ama-pipeline-start] 

*PipelineRun* 은 파이프라인의 단일 실행을 나타내며, 특정 호출에 사용될 소스코드 및 이미지 리소스와 연결됩니다.

이 대화 상자에서 _build-artifact_ 단계의 소스코드 저장소와 _update-manifest-and-push_ 단계에서 배포할 타겟 네임스페이스의 최종 값을 바인딩할 수 있습니다. workspaces 섹션을 다음 값으로 업데이트한 후 *Start* 를 클릭합니다. 

[참고] 
==== 
`git-url, git-branch, app-subdir, target-namespace 및 target-registry` 와 같은 다른 key에 대한 기본값은 그대로 둡니다. 
==== 

* ws: `customers-pvc` in *PersistentVolumeClaim* 

image::ama-pipeline-start-popup.png[ama-pipeline-start-popup] 

*java-deployment-pipeline* 파이프라인을 시작하면 _pipelinerun_ 이 인스턴스화되고 파이프라인에 정의된 작업을 실행하기 위해 파드가 생성됩니다. 몇 분 후 파이프라인이 성공적으로 완료됩니다. 각 단계 위로 마우스를 올려서 진행 상황의 간단한 스냅샷을 보거나, 단계를 클릭하여 자세한 로그를 확인할 수 있습니다.

image::ama-pipeline-complete.png[ama-pipeline-complete] 

=== 2.2.3 더 나은 Topology View를 위한 레이블 추가 

Globex 리테일 시스템은 OpenShift 클러스터에 여러 마이크로서비스를 배포했습니다. 각 마이크로서비스는 다른 마이크로서비스 및 데이터베이스와 복잡한 관계를 가지고 있습니다. 이 아키텍처는 개발자 및 SRE에게 즉시 이해되지 않을 수 있습니다. 다행히 OpenShift 개발자 콘솔은 유용한 레이블과 주석이 포함된 직관적인 `Topology View` 를 제공합니다. 이러한 레이블은 같은 네임스페이스에 배포된 애플리케이션 간의 명시적인 관계를 상세하게 나타냅니다.

각 애플리케이션에 사용된 _언어_, _프레임워크_ 및 _런타임_ 을 표시하기 위해 각 배포에 레이블과 주석을 추가하려면 다음 명령을 실행하세요:

[.console-input]
[source,bash]
----
oc project retail-%USERID% && \
oc label deployment/inventory app.kubernetes.io/part-of=inventory app.openshift.io/runtime=quarkus --overwrite && \
oc label deployment/postgresql-inventory app.kubernetes.io/part-of=inventory app.openshift.io/runtime=postgresql --overwrite && \
oc annotate deployment/inventory app.openshift.io/connects-to='[{"apiVersion":"apps/v1","kind":"Deployment","name":"postgresql-inventory"}]' --overwrite && \
oc label deployment/orders app.kubernetes.io/part-of=orders app.openshift.io/runtime=spring --overwrite && \
oc label deployment/postgresql-orders app.kubernetes.io/part-of=orders app.openshift.io/runtime=postgresql --overwrite && \
oc annotate deployment/orders app.openshift.io/connects-to='[{"apiVersion":"apps/v1","kind":"Deployment","name":"postgresql-orders"}]' --overwrite && \
oc label deployment/customers app.kubernetes.io/part-of=customers app.openshift.io/runtime=tomcat --overwrite && \
oc annotate deployment/customers app.openshift.io/connects-to='[{"apiVersion":"apps/v1","kind":"Deployment","name":"postgresql-customer"}]' --overwrite && \
oc label deployment/postgresql-customer app.kubernetes.io/part-of=customers app.openshift.io/runtime=postgresql --overwrite && \
oc label deployment/ordersfrontend app.kubernetes.io/part-of=ordersfrontend app.openshift.io/runtime=nodejs --overwrite && \
oc annotate deployment/ordersfrontend app.openshift.io/connects-to=gateway --overwrite && \
oc label deployment/gateway app.kubernetes.io/part-of=gateway app.openshift.io/runtime=spring --overwrite && \
oc annotate deployment/gateway app.openshift.io/connects-to='["inventory","orders","customers",{"apiVersion":"apps/v1","kind":"Deployment","name":"customers"}]' --overwrite
----

[NOTE]
==== 
`gateway` 와 `customers` 사이에 연결이 없을 수 있습니다. 이 경우 `gateway` 에서 `customers` _Dev Console_ 로 화살표를 드래그하여 연결을 추가할 수 있습니다. 이는 두 개가 서로 연결되어 있음을 나타내는 시각적 단서입니다.
==== 

다음으로, retail-%USERID% 프로젝트의 _Developer perspective_ 에서 토폴로지 보기로 이동하면 애플리케이션 배포가 다음과 같이 표시됩니다:

다음으로, Developer perspective에서 `retail-%USERID%` 프로젝트의 link:https://console-openshift-console.%SUBDOMAIN%/topology/ns/retail-%USERID%?view=graph[Topology View^]로 돌아가면 애플리케이션 배포가 다음과 같이 표시됩니다:

image::app-topology.png[app-topology] 

== 축하합니다!

CI/CD 파이프라인을 사용하여 OpenShift에 현대화된 customer 애플리케이션을 구축하고 배포했으며, OpenShift Virtualization에서 실행 중인 새로운 PostgreSQL 데이터베이스에 customers 마이크로서비스를 연결했습니다.

다음 단계에서는 `gateway` 를 업데이트하여 정적 IP주소 대신 동적 검색(dynamic discovery)을 사용해 새로운 `customers` 서비스에 연결합니다.

이후 애플리케이션을 OpenShift GitOps와 통합하여 애플리케이션 구성 요소를 선언적으로 설명하고 배포된 애플리케이션을 자동으로 동기화합니다. 이는 소프트웨어 제공 방식을 개선하고 구성 불일치(configuration drift) 가능성을 최소화하며 장기적으로 더 나은 감사(auditability) 기능을 제공합니다. 시작해 봅시다!